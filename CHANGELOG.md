
# Changelog: SSTable Cache Management Improvements 22/03/2025

## 问题分析

当前NoKV在启动时会将所有SSTable一次性加载到内存，存在以下问题：

- **内存占用高**：一次性加载所有SSTable导致内存使用量与数据集大小线性增长
- **缓存利用不足**：虽然已实现cache结构，但未被有效用于按需加载SSTable
- **扩展性受限**：当数据集远大于可用内存时，系统性能会显著下降

相关代码：
```go
// levelManager.build()中直接加载所有表
for fID, tableInfo := range manifest.Tables {
    t := openTable(lm, fileName, nil)
    lm.levels[tableInfo.Level].add(t)
}
```

## 设计目标

1. 优化内存使用，支持超大数据集
2. 充分利用现有缓存系统(utils/cache)实现按需加载
3. 保持现有接口不变，内部实现改变
4. 平衡内存使用与查询性能

## 架构设计

### 表引用与表实例分离

```
表引用(TableRef)
 ├── ID (文件ID)
 ├── MinKey (最小键)
 ├── MaxKey (最大键)
 ├── Size (文件大小)
 └── BloomFilter (可选)
```

### 缓存管理优化

```
cache
 ├── indexs - 表缓存 (fid -> table)
 │    └── 按LRU/S2LRU策略管理表生命周期
 │
 ├── blocks - 块缓存 (fid_offset -> block)
 │    └── 按LRU/S2LRU策略管理块生命周期
 │
 └── tablesMeta - 表元数据 (常驻内存)
      └── 轻量级，包含表的基本信息
```

### 查询流程优化

```
1. 表定位: 通过表引用找到可能包含目标键的表ID
2. 表获取: 从缓存获取表实例，缓存未命中则加载
3. 块定位: 在表中找到可能包含目标键的块偏移
4. 块获取: 从缓存获取块数据，缓存未命中则加载
5. 键查找: 在块中查找目标键
```

## 实现计划

### 阶段一：基础缓存增强

1. 扩展现有cache结构
   - 添加表元数据管理
   - 实现getTable、getBlock方法

2. 修改table.close()方法
   - 确保释放mmap资源
   - 支持缓存淘汰机制

### 阶段二：查询流程改进

1. 修改levelHandler实现
   - 支持通过表引用而非表实例进行查询
   - 改进searchLNSST方法使用缓存

2. 优化缓存配置
   - 根据系统资源调整缓存大小
   - 实现自适应缓存策略

### 阶段三：启动流程改进

1. 修改levelManager.build方法
   - 只加载表元数据，不加载表实例
   - 创建轻量级表引用而非完整表对象

2. 完善资源管理
   - 定期清理不活跃表
   - 监控内存使用并调整缓存大小

## 预期效果

1. **内存效率**: 内存使用量与活跃数据集相关，而非总数据集大小
2. **启动速度**: 启动时间大幅减少，不再受数据集大小限制
3. **性能平衡**: 热点数据保持在内存，冷数据按需加载
4. **扩展性**: 支持远大于物理内存的数据集规模
5. **资源管理**: 有效控制文件句柄数量和mmap映射数量

## 参考实现

这一改进参考了以下成熟实现的设计思路：
- **Badger**: 表缓存和延迟加载机制
- **LevelDB/RocksDB**: 表元数据与实例分离
- **NoKV现有utils/cache**: 高效缓存实现
