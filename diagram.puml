@startuml
namespace NoKV {
    interface CoreAPI  {
        + Set(data *utils.Entry) error
        + Get(key []byte) (*utils.Entry, error)
        + Del(key []byte) error
        + NewIterator(opt *utils.Options) utils.Iterator
        + Info() *Stats
        + Close() error

    }
    class DB << (S,Aquamarine) >> {
        - opt *Options
        - lsm *lsm.LSM
        - vlog *valueLog
        - stats *Stats
        - flushChan <font color=blue>chan</font> flushTask
        - writeCh <font color=blue>chan</font> *request
        - blockWrites int32
        - vhead *utils.ValuePtr
        - logRotates int32
        - isClosed uint32
        - orc *oracle

        - shouldWriteValueToLSM(e *utils.Entry) bool
        - sendToWriteCh(entries []*utils.Entry) (*request, error)
        - batchSet(entries []*utils.Entry) error
        - doWrites(lc *utils.Closer) 
        - getMemTables() ([]*lsm.MemTable, <font color=blue>func</font>() )
        - writeRequests(reqs []*request) error
        - writeToLSM(b *request) error
        - pushHead(ft flushTask) error
        - valueThreshold() int64
        - newTransaction(update bool) *Txn
        - initVLog() 
        - getHead() (*utils.ValuePtr, uint64)
        - replayFunction() <font color=blue>func</font>(*utils.Entry, *utils.ValuePtr) error
        - updateHead(ptrs []*utils.ValuePtr) 

        + Close() error
        + Del(key []byte) error
        + Set(data *utils.Entry) error
        + Get(key []byte) (*utils.Entry, error)
        + Info() *Stats
        + RunValueLogGC(discardRatio float64) error
        + IsClosed() bool
        + NewIterator(opt *utils.Options) utils.Iterator
        + NewTransaction(update bool) *Txn
        + View(fn <font color=blue>func</font>(*Txn) error) error
        + Update(fn <font color=blue>func</font>(*Txn) error) error

    }
    class DBIterator << (S,Aquamarine) >> {
        - iitr utils.Iterator
        - vlog *valueLog

        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() utils.Item
        + Close() error
        + Seek(key []byte) 

    }
    class Item << (S,Aquamarine) >> {
        - e *utils.Entry

        + Entry() *utils.Entry

    }
    class IteratorOptions << (S,Aquamarine) >> {
        - prefixIsKey bool

        + Reverse bool
        + AllVersions bool
        + InternalAccess bool
        + Prefix []byte
        + SinceTs uint64

    }
    class Options << (S,Aquamarine) >> {
        + ValueThreshold int64
        + WorkDir string
        + MemTableSize int64
        + SSTableMaxSz int64
        + MaxBatchCount int64
        + MaxBatchSize int64
        + ValueLogFileSize int
        + VerifyValueChecksum bool
        + ValueLogMaxEntries uint32
        + LogRotatesToFlush int32
        + MaxTableSize int64
        + DetectConflicts bool

    }
    class Stats << (S,Aquamarine) >> {
        - closer *utils.Closer

        + EntryNum int64

        - close() error

        + StartStats() 

    }
    class Txn << (S,Aquamarine) >> {
        - readTs uint64
        - commitTs uint64
        - size int64
        - count int64
        - db *DB
        - reads []uint64
        - conflictKeys <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}
        - readsLock sync.Mutex
        - pendingWrites <font color=blue>map</font>[string]*utils.Entry
        - numIterators int32
        - discarded bool
        - doneRead bool
        - update bool

        - newPendingWritesIterator(reversed bool) *pendingWritesIterator
        - checkSize(e *utils.Entry) error
        - modify(e *utils.Entry) error
        - addReadKey(key []byte) 
        - commitAndSend() (<font color=blue>func</font>() error, error)
        - commitPrecheck() error

        + Set(key []byte, val []byte) error
        + SetEntry(e *utils.Entry) error
        + Delete(key []byte) error
        + Get(key []byte) (*Item, error)
        + Discard() 
        + Commit() error
        + CommitWith(cb <font color=blue>func</font>(error) ) 
        + ReadTs() uint64
        + NewIterator(opt IteratorOptions) *TxnIterator
        + NewKeyIterator(key []byte, opt IteratorOptions) *TxnIterator

    }
    class TxnIterator << (S,Aquamarine) >> {
        - iitr utils.Iterator
        - txn *Txn
        - readTs uint64
        - opt IteratorOptions
        - item *Item
        - lastKey []byte
        - closed bool
        - latestTs uint64

        + Item() *Item
        + Valid() bool
        + ValidForPrefix(prefix []byte) bool
        + Close() 
        + Next() 
        + Seek(key []byte) uint64
        + Rewind() 

    }
    class committedTxn << (S,Aquamarine) >> {
        - ts uint64
        - conflictKeys <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

    }
    class flushTask << (S,Aquamarine) >> {
        - mt *utils.Skiplist
        - vptr *utils.ValuePtr
        - dropPrefixes [][]byte

    }
    class lfDiscardStats << (S,Aquamarine) >> {
        - m <font color=blue>map</font>[uint32]int64
        - flushChan <font color=blue>chan</font> <font color=blue>map</font>[uint32]int64
        - closer *utils.Closer
        - updatesSinceFlush int

    }
    class oracle << (S,Aquamarine) >> {
        - detectConflicts bool
        - writeChLock sync.Mutex
        - nextTxnTs uint64
        - txnMark *utils.WaterMark
        - discardTs uint64
        - readMark *utils.WaterMark
        - committedTxns []committedTxn
        - lastCleanupTs uint64
        - closer *utils.Closer

        - readTs() uint64
        - nextTs() uint64
        - incrementNextTs() 
        - setDiscardTs(ts uint64) 
        - discardAtOrBelow() uint64
        - hasConflict(txn *Txn) bool
        - newCommitTs(txn *Txn) (uint64, bool)
        - doneRead(txn *Txn) 
        - cleanupCommittedTransactions() 
        - doneCommit(cts uint64) 

        + Stop() 

    }
    class pendingWritesIterator << (S,Aquamarine) >> {
        - entries []*utils.Entry
        - nextIdx int
        - readTs uint64
        - reversed bool

        + Item() utils.Item
        + Next() 
        + Rewind() 
        + Seek(key []byte) 
        + Key() []byte
        + Value() utils.ValueStruct
        + Valid() bool
        + Close() error

    }
    class reason << (S,Aquamarine) >> {
        - total float64
        - discard float64
        - count int

    }
    class request << (S,Aquamarine) >> {
        - ref int32

        + Entries []*utils.Entry
        + Ptrs []*utils.ValuePtr
        + Wg sync.WaitGroup
        + Err error

        - reset() 

        + IncrRef() 
        + DecrRef() 
        + Wait() error

    }
    class safeRead << (S,Aquamarine) >> {
        - k []byte
        - v []byte
        - recordOffset uint32
        - lf *file.LogFile

        + Entry(reader io.Reader) (*utils.Entry, error)

    }
    class sampler << (S,Aquamarine) >> {
        - lf *file.LogFile
        - sizeRatio float64
        - countRatio float64
        - fromBeginning bool

    }
    class txnCb << (S,Aquamarine) >> {
        - commit <font color=blue>func</font>() error
        - user <font color=blue>func</font>(error) 
        - err error

    }
    class valueLog << (S,Aquamarine) >> {
        - dirPath string
        - filesLock sync.RWMutex
        - filesMap <font color=blue>map</font>[uint32]*file.LogFile
        - maxFid uint32
        - filesToBeDeleted []uint32
        - numActiveIterators int32
        - db *DB
        - writableLogOffset uint32
        - numEntriesWritten uint32
        - opt Options
        - garbageCh <font color=blue>chan</font> <font color=blue>struct</font>{}
        - lfDiscardStats *lfDiscardStats

        - newValuePtr(e *utils.Entry) (*utils.ValuePtr, error)
        - open(db *DB, ptr *utils.ValuePtr, replayFn utils.LogEntry) error
        - read(vp *utils.ValuePtr) ([]byte, <font color=blue>func</font>() , error)
        - write(reqs []*request) error
        - close() error
        - runGC(discardRatio float64, head *utils.ValuePtr) error
        - doRunGC(lf *file.LogFile, discardRatio float64) error
        - rewrite(f *file.LogFile) error
        - iteratorCount() int
        - decrIteratorCount() error
        - deleteLogFile(lf *file.LogFile) error
        - validateWrites(reqs []*request) error
        - getUnlockCallback(lf *file.LogFile) <font color=blue>func</font>() 
        - readValueBytes(vp *utils.ValuePtr) ([]byte, *file.LogFile, error)
        - getFileRLocked(vp *utils.ValuePtr) (*file.LogFile, error)
        - woffset() uint32
        - populateFilesMap() error
        - createVlogFile(fid uint32) (*file.LogFile, error)
        - sortedFids() []uint32
        - replayLog(lf *file.LogFile, offset uint32, replayFn utils.LogEntry) error
        - iterate(lf *file.LogFile, offset uint32, fn utils.LogEntry) (uint32, error)
        - populateDiscardStats() error
        - fpath(fid uint32) string
        - sync(fid uint32) error
        - set(entry *utils.Entry) error
        - get(entry *utils.Entry) (*utils.Entry, error)
        - flushDiscardStats() 
        - pickLog(head *utils.ValuePtr) []*file.LogFile
        - sample(samp *sampler, discardRatio float64) (*reason, error)
        - waitOnGC(lc *utils.Closer) 

    }
}
"sync.RWMutex" *-- "NoKV.DB"
"sync.RWMutex" *-- "NoKV.lfDiscardStats"
"sync.Mutex" *-- "NoKV.oracle"

"NoKV.CoreAPI" <|-- "NoKV.DB"
"utils.Iterator" <|-- "NoKV.DBIterator"
"utils.Item" <|-- "NoKV.Item"
"utils.Iterator" <|-- "NoKV.pendingWritesIterator"

namespace cache {
    class BloomFilter << (S,Aquamarine) >> {
        - bitmap Filter
        - k uint8

        - reset() 

        + MayContainKey(k []byte) bool
        + MayContain(h uint32) bool
        + Len() int32
        + InsertKey(k []byte) bool
        + Insert(h uint32) bool
        + AllowKey(k []byte) bool
        + Allow(h uint32) bool

    }
    class Cache << (S,Aquamarine) >> {
        - m sync.RWMutex
        - lru *windowLRU
        - slru *segmentedLRU
        - door *BloomFilter
        - c *cmSketch
        - t int32
        - threshold int32
        - data <font color=blue>map</font>[uint64]*list.Element

        - set(key <font color=blue>interface</font>{}, value <font color=blue>interface</font>{}) bool
        - get(key <font color=blue>interface</font>{}) (<font color=blue>interface</font>{}, bool)
        - del(key <font color=blue>interface</font>{}) (<font color=blue>interface</font>{}, bool)
        - keyToHash(key <font color=blue>interface</font>{}) (uint64, uint64)

        + Set(key <font color=blue>interface</font>{}, value <font color=blue>interface</font>{}) bool
        + Get(key <font color=blue>interface</font>{}) (<font color=blue>interface</font>{}, bool)
        + Del(key <font color=blue>interface</font>{}) (<font color=blue>interface</font>{}, bool)
        + String() string

    }
    class Options << (S,Aquamarine) >> {
        - lruPct uint8

    }
    class cache.Filter << (T, #FF7700) >>  {
    }
    class cache.cmRow << (T, #FF7700) >>  {
    }
    class cmRow << (S,Aquamarine) >> {
        - get(n uint64) byte
        - increment(n uint64) 
        - reset() 
        - clear() 
        - string() string

    }
    class cmSketch << (S,Aquamarine) >> {
        - rows []cmRow
        - seed []uint64
        - mask uint64

        + Increment(hashed uint64) 
        + Estimate(hashed uint64) int64
        + Reset() 
        + Clear() 

    }
    class segmentedLRU << (S,Aquamarine) >> {
        - data <font color=blue>map</font>[uint64]*list.Element
        - stageOneCap int
        - stageOne *list.List

        - add(newitem storeItem) 
        - get(v *list.Element) 
        - victim() *storeItem

        + Len() int
        + String() string

    }
    class storeItem << (S,Aquamarine) >> {
        - stage int
        - key uint64
        - conflict uint64
        - value <font color=blue>interface</font>{}

    }
    class stringStruct << (S,Aquamarine) >> {
        - str unsafe.Pointer
        - len int

    }
    class windowLRU << (S,Aquamarine) >> {
        - data <font color=blue>map</font>[uint64]*list.Element
        - cap int
        - list *list.List

        - add(newitem storeItem) (storeItem, bool)
        - get(v *list.Element) 

        + String() string

    }
}


namespace file {
    interface CoreFile  {
        + Close() error
        + Truncature(n int64) error
        + ReName(name string) error
        + NewReader(offset int) io.Reader
        + Bytes(off int, sz int) ([]byte, error)
        + AllocateSlice(sz int, offset int) ([]byte, int, error)
        + Sync() error
        + Delete() error
        + Slice(offset int) []byte

    }
    class LogFile << (S,Aquamarine) >> {
        - size uint32
        - f *MmapFile

        + Lock sync.RWMutex
        + FID uint32

        + Open(opt *Options) error
        + Read(p *utils.ValuePtr) ([]byte, error)
        + DoneWriting(offset uint32) error
        + Write(offset uint32, buf []byte) error
        + Truncate(offset int64) error
        + Close() error
        + Size() int64
        + AddSize(offset uint32) 
        + Bootstrap() error
        + Init() error
        + FileName() string
        + Seek(offset int64, whence int) (int64, error)
        + FD() *os.File
        + Sync() error
        + EncodeEntry(e *utils.Entry, buf *bytes.Buffer, offset uint32) (int, error)
        + DecodeEntry(buf []byte, offset uint32) (*utils.Entry, error)

    }
    class Manifest << (S,Aquamarine) >> {
        + Levels []levelManifest
        + Tables <font color=blue>map</font>[uint64]TableManifest
        + Creations int
        + Deletions int

        - asChanges() []*pb.ManifestChange

    }
    class ManifestFile << (S,Aquamarine) >> {
        - opt *Options
        - f *os.File
        - lock sync.Mutex
        - deletionsRewriteThreshold int
        - manifest *Manifest

        - rewrite() error
        - addChanges(changesParam []*pb.ManifestChange) error

        + Close() error
        + AddChanges(changesParam []*pb.ManifestChange) error
        + AddTableMeta(levelNum int, t *TableMeta) error
        + RevertToManifest(idMap <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}) error
        + GetManifest() *Manifest

    }
    class MmapFile << (S,Aquamarine) >> {
        + Data []byte
        + Fd *os.File
        + Data []byte
        + Fd *os.File

        + NewReader(offset int) io.Reader
        + Bytes(off int, sz int) ([]byte, error)
        + Slice(offset int) []byte
        + AllocateSlice(sz int, offset int) ([]byte, int, error)
        + AppendBuffer(offset uint32, buf []byte) error
        + Sync() error
        + Delete() error
        + Close() error
        + Truncature(maxSz int64) error
        + ReName(name string) error
        + NewReader(offset int) io.Reader
        + Bytes(off int, sz int) ([]byte, error)
        + Slice(offset int) []byte
        + AllocateSlice(sz int, offset int) ([]byte, int, error)
        + AppendBuffer(offset uint32, buf []byte) error
        + Sync() error
        + Delete() error
        + Close() error
        + Truncature(maxSz int64) error
        + ReName(name string) error

    }
    class Options << (S,Aquamarine) >> {
        + FID uint64
        + FileName string
        + Dir string
        + Path string
        + Flag int
        + MaxSz int

    }
    class SSTable << (S,Aquamarine) >> {
        - lock *sync.RWMutex
        - f *MmapFile
        - maxKey []byte
        - minKey []byte
        - idxTables *pb.TableIndex
        - hasBloomFilter bool
        - idxLen int
        - idxStart int
        - fid uint64
        - createdAt time.Time
        - lock *sync.RWMutex
        - f *MmapFile
        - maxKey []byte
        - minKey []byte
        - idxTables *pb.TableIndex
        - hasBloomFilter bool
        - idxLen int
        - idxStart int
        - fid uint64
        - createdAt time.Time

        - initTable() (*pb.BlockOffset, error)
        - read(off int, sz int) ([]byte, error)
        - readCheckError(off int, sz int) []byte
        - initTable() (*pb.BlockOffset, error)
        - read(off int, sz int) ([]byte, error)
        - readCheckError(off int, sz int) []byte

        + Init() error
        + SetMaxKey(maxKey []byte) 
        + Close() error
        + Indexs() *pb.TableIndex
        + MaxKey() []byte
        + MinKey() []byte
        + FID() uint64
        + HasBloomFilter() bool
        + Bytes(off int, sz int) ([]byte, error)
        + Size() int64
        + GetCreatedAt() *time.Time
        + SetCreatedAt(t *time.Time) 
        + Detele() error
        + Truncature(size int64) error
        + Init() error
        + SetMaxKey(maxKey []byte) 
        + Close() error
        + Indexs() *pb.TableIndex
        + MaxKey() []byte
        + MinKey() []byte
        + FID() uint64
        + HasBloomFilter() bool
        + Bytes(off int, sz int) ([]byte, error)
        + Size() int64
        + GetCreatedAt() *time.Time
        + SetCreatedAt(t *time.Time) 
        + Detele() error
        + Truncature(size int64) error

    }
    class SafeRead << (S,Aquamarine) >> {
        + K []byte
        + V []byte
        + RecordOffset uint32
        + LF *WalFile

        + MakeEntry(reader io.Reader) (*utils.Entry, error)

    }
    class TableManifest << (S,Aquamarine) >> {
        + Level uint8
        + Checksum []byte

    }
    class TableMeta << (S,Aquamarine) >> {
        + ID uint64
        + Checksum []byte

    }
    class WalFile << (S,Aquamarine) >> {
        - lock *sync.RWMutex
        - f *MmapFile
        - opts *Options
        - buf *bytes.Buffer
        - size uint32
        - writeAt uint32

        + Fid() uint64
        + Close() error
        + Name() string
        + Size() uint32
        + Write(entry *utils.Entry) error
        + Iterate(readOnly bool, offset uint32, fn utils.LogEntry) (uint32, error)
        + Truncate(end int64) error

    }
    class bufReader << (S,Aquamarine) >> {
        - reader *bufio.Reader
        - count int64

        + Read(p []byte) (int, error)

    }
    class levelManifest << (S,Aquamarine) >> {
        + Tables <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

    }
    class mmapReader << (S,Aquamarine) >> {
        - offset int
        - offset int

        + Data []byte
        + Data []byte

        + Read(buf []byte) (int, error)
        + Read(buf []byte) (int, error)

    }
}

"file.CoreFile" <|-- "file.MmapFile"

namespace lsm {
    class ConcatIterator << (S,Aquamarine) >> {
        - idx int
        - cur utils.Iterator
        - iters []utils.Iterator
        - tables []*table
        - options *utils.Options

        - setIdx(idx int) 

        + Rewind() 
        + Valid() bool
        + Item() utils.Item
        + Seek(key []byte) 
        + Next() 
        + Close() error

    }
    class Item << (S,Aquamarine) >> {
        - e *utils.Entry

        + Entry() *utils.Entry

    }
    class Iterator << (S,Aquamarine) >> {
        - it Item
        - iters []utils.Iterator

        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() utils.Item
        + Close() error
        + Seek(key []byte) 

    }
    class LSM << (S,Aquamarine) >> {
        - lock sync.RWMutex
        - memTable *memTable
        - immutables []*memTable
        - levels *levelManager
        - option *Options
        - closer *utils.Closer
        - maxMemFID uint32

        - newCompactStatus() *compactStatus
        - initLevelManager(opt *Options) *levelManager
        - recovery() (*memTable, []*memTable)
        - openMemTable(fid uint64) (*memTable, error)

        + NewIterators(opt *utils.Options) []utils.Iterator
        + Close() error
        + StartCompacter() 
        + Set(entry *utils.Entry) error
        + Get(key []byte) (*utils.Entry, error)
        + MemSize() int64
        + MemTableIsNil() bool
        + GetSkipListFromMemTable() *utils.Skiplist
        + Rotate() 
        + GetMemTables() ([]*memTable, <font color=blue>func</font>() )
        + NewMemtable() *memTable

    }
    class MergeIterator << (S,Aquamarine) >> {
        - left node
        - right node
        - small *node
        - curKey []byte
        - reverse bool

        - fix() 
        - bigger() *node
        - swapSmall() 
        - setCurrent() 

        + Next() 
        + Rewind() 
        + Seek(key []byte) 
        + Valid() bool
        + Item() utils.Item
        + Close() error

    }
    class Options << (S,Aquamarine) >> {
        + WorkDir string
        + MemTableSize int64
        + SSTableMaxSz int64
        + BlockSize int
        + BloomFalsePositive float64
        + NumCompactors int
        + BaseLevelSize int64
        + LevelSizeMultiplier int
        + TableSizeMultiplier int
        + BaseTableSize int64
        + NumLevelZeroTables int
        + MaxLevelNum int
        + DiscardStatsCh *<font color=blue>chan</font> <font color=blue>map</font>[uint32]int64

    }
    class block << (S,Aquamarine) >> {
        - offset int
        - checksum []byte
        - entriesIndexStart int
        - chkLen int
        - data []byte
        - baseKey []byte
        - entryOffsets []uint32
        - end int
        - estimateSz int64

        - verifyCheckSum() error

    }
    class blockBuffer << (S,Aquamarine) >> {
        - b []byte

    }
    class blockIterator << (S,Aquamarine) >> {
        - data []byte
        - idx int
        - err error
        - baseKey []byte
        - key []byte
        - val []byte
        - entryOffsets []uint32
        - block *block
        - tableID uint64
        - blockID int
        - prevOverlap uint16
        - it utils.Item

        - setBlock(b *block) 
        - seekToFirst() 
        - seekToLast() 
        - seek(key []byte) 
        - setIdx(i int) 

        + Error() error
        + Next() 
        + Valid() bool
        + Rewind() bool
        + Item() utils.Item
        + Close() error

    }
    class buildData << (S,Aquamarine) >> {
        - blockList []*block
        - index []byte
        - checksum []byte
        - size int

        + Copy(dst []byte) int

    }
    class cache << (S,Aquamarine) >> {
        - indexs *cache.Cache
        - blocks *cache.Cache

        - close() error
        - addIndex(fid uint64, t *table) 

    }
    class compactDef << (S,Aquamarine) >> {
        - compactorId int
        - t targets
        - p compactionPriority
        - thisLevel *levelHandler
        - nextLevel *levelHandler
        - top []*table
        - bot []*table
        - thisRange keyRange
        - nextRange keyRange
        - splits []keyRange
        - thisSize int64
        - dropPrefixes [][]byte

        - lockLevels() 
        - unlockLevels() 

    }
    class compactStatus << (S,Aquamarine) >> {
        - levels []*levelCompactStatus
        - tables <font color=blue>map</font>[uint64]<font color=blue>struct</font>{}

        - overlapsWith(level int, this keyRange) bool
        - delSize(l int) int64
        - delete(cd compactDef) 
        - compareAndAdd(_ thisAndNextLevelRLocked, cd compactDef) bool

    }
    class compactionPriority << (S,Aquamarine) >> {
        - level int
        - score float64
        - adjusted float64
        - dropPrefixes [][]byte
        - t targets

    }
    class header << (S,Aquamarine) >> {
        - overlap uint16
        - diff uint16

        - decode(buf []byte) 
        - encode() []byte

    }
    class keyRange << (S,Aquamarine) >> {
        - left []byte
        - right []byte
        - inf bool
        - size int64

        - isEmpty() bool
        - equals(dst keyRange) bool
        - extend(kr keyRange) 
        - overlapsWith(dst keyRange) bool

        + String() string

    }
    class levelCompactStatus << (S,Aquamarine) >> {
        - ranges []keyRange
        - delSize int64

        - overlapsWith(dst keyRange) bool
        - remove(dst keyRange) bool
        - debug() string

    }
    class levelHandler << (S,Aquamarine) >> {
        - levelNum int
        - tables []*table
        - totalSize int64
        - totalStaleSize int64
        - lm *levelManager

        - close() error
        - add(t *table) 
        - addBatch(ts []*table) 
        - getTotalSize() int64
        - addSize(t *table) 
        - subtractSize(t *table) 
        - numTables() int
        - searchL0SST(key []byte) (*utils.Entry, error)
        - searchLNSST(key []byte) (*utils.Entry, error)
        - getTable(key []byte) *table
        - isLastLevel() bool
        - overlappingTables(_ levelHandlerRLocked, kr keyRange) (int, int)
        - replaceTables(toDel []*table, toAdd []*table) error
        - deleteTables(toDel []*table) error
        - iterators() []utils.Iterator

        + Get(key []byte) (*utils.Entry, error)
        + Sort() 

    }
    class levelHandlerRLocked << (S,Aquamarine) >> {
    }
    class levelIterator << (S,Aquamarine) >> {
        - it *utils.Item
        - iters []*Iterator

        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() utils.Item
        + Close() error
        + Seek(key []byte) 

    }
    class levelManager << (S,Aquamarine) >> {
        - maxFID uint64
        - opt *Options
        - cache *cache
        - manifestFile *file.ManifestFile
        - levels []*levelHandler
        - lsm *LSM
        - compactState *compactStatus

        - runCompacter(id int) 
        - runOnce(id int) bool
        - run(id int, p compactionPriority) bool
        - doCompact(id int, p compactionPriority) error
        - pickCompactLevels() []compactionPriority
        - lastLevel() *levelHandler
        - levelTargets() targets
        - fillTables(cd *compactDef) bool
        - sortByHeuristic(tables []*table, cd *compactDef) 
        - runCompactDef(id int, l int, cd compactDef) error
        - compactBuildTables(lev int, cd compactDef) ([]*table, <font color=blue>func</font>() error, error)
        - addSplits(cd *compactDef) 
        - sortByStaleDataSize(tables []*table, cd *compactDef) 
        - fillMaxLevelTables(tables []*table, cd *compactDef) bool
        - fillTablesL0(cd *compactDef) bool
        - fillTablesL0ToLbase(cd *compactDef) bool
        - fillTablesL0ToL0(cd *compactDef) bool
        - updateDiscardStats(discardStats <font color=blue>map</font>[uint32]int64) 
        - subcompact(it utils.Iterator, kr keyRange, cd compactDef, inflightBuilders *utils.Throttle, res <font color=blue>chan</font> *table) 
        - checkOverlap(tables []*table, lev int) bool
        - close() error
        - iterators() []utils.Iterator
        - loadCache() 
        - loadManifest() error
        - build() error
        - flush(immutable *memTable) error

        + NewIterators(options *utils.Options) []utils.Iterator
        + Get(key []byte) (*utils.Entry, error)

    }
    class lsm.MemTable << (T, #FF7700) >>  {
    }
    class memIterator << (S,Aquamarine) >> {
        - innerIter utils.Iterator

        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() utils.Item
        + Close() error
        + Seek(key []byte) 

    }
    class memTable << (S,Aquamarine) >> {
        - lsm *LSM
        - wal *file.WalFile
        - sl *utils.Skiplist
        - buf *bytes.Buffer
        - maxVersion uint64

        - close() error
        - set(entry *utils.Entry) error
        - replayFunction(opt *Options) <font color=blue>func</font>(*utils.Entry, *utils.ValuePtr) error

        + NewIterator(opt *utils.Options) utils.Iterator
        + Get(key []byte) (*utils.Entry, error)
        + Size() int64
        + UpdateSkipList() error
        + IncrRef() 
        + DecrRef() 

    }
    class node << (S,Aquamarine) >> {
        - valid bool
        - entry *utils.Entry
        - iter utils.Iterator
        - merge *MergeIterator
        - concat *ConcatIterator

        - setIterator(iter utils.Iterator) 
        - setKey() 
        - next() 
        - rewind() 
        - seek(key []byte) 

    }
    class table << (S,Aquamarine) >> {
        - ss *file.SSTable
        - lm *levelManager
        - fid uint64
        - ref int32

        - indexKey() uint64
        - getEntry(key []byte, block []byte, idx int) (*utils.Entry, error)
        - block(idx int) (*block, error)
        - read(off int, sz int) ([]byte, error)
        - blockCacheKey(idx int) []byte
        - offsets(ko *pb.BlockOffset, i int) bool

        + Search(key []byte, maxVs *uint64) (*utils.Entry, error)
        + NewIterator(options *utils.Options) utils.Iterator
        + Size() int64
        + GetCreatedAt() *time.Time
        + Delete() error
        + StaleDataSize() uint32
        + DecrRef() error
        + IncrRef() 

    }
    class tableBuilder << (S,Aquamarine) >> {
        - sstSize int64
        - curBlock *block
        - opt *Options
        - blockList []*block
        - keyCount uint32
        - keyHashes []uint32
        - maxVersion uint64
        - baseKey []byte
        - staleDataSize int
        - estimateSz int64

        - add(e *utils.Entry, isStale bool) 
        - empty() bool
        - finish() []byte
        - tryFinishBlock(e *utils.Entry) bool
        - finishBlock() 
        - append(data []byte) 
        - allocate(need int) []byte
        - calculateChecksum(data []byte) []byte
        - keyDiff(newKey []byte) []byte
        - flush(lm *levelManager, tableName string) (*table, error)
        - done() buildData
        - buildIndex(bloom []byte) ([]byte, uint32)
        - writeBlockOffsets(tableIndex *pb.TableIndex) []*pb.BlockOffset
        - writeBlockOffset(bl *block, startOffset uint32) *pb.BlockOffset

        + AddStaleKey(e *utils.Entry) 
        + AddKey(e *utils.Entry) 
        + Close() 
        + ReachedCapacity() bool

    }
    class tableIterator << (S,Aquamarine) >> {
        - it utils.Item
        - opt *utils.Options
        - t *table
        - blockPos int
        - bi *blockIterator
        - err error

        - seekToFirst() 
        - seekToLast() 
        - seekHelper(blockIdx int, key []byte) 

        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() utils.Item
        + Close() error
        + Seek(key []byte) 

    }
    class targets << (S,Aquamarine) >> {
        - baseLevel int
        - targetSz []int64
        - fileSz []int64

    }
    class thisAndNextLevelRLocked << (S,Aquamarine) >> {
    }
}
"sync.RWMutex" *-- "lsm.compactStatus"
"sync.RWMutex" *-- "lsm.levelHandler"

"utils.Iterator" <|-- "lsm.ConcatIterator"
"utils.Item" <|-- "lsm.Item"
"utils.Iterator" <|-- "lsm.Iterator"
"utils.Iterator" <|-- "lsm.MergeIterator"
"utils.Iterator" <|-- "lsm.levelIterator"
"utils.Iterator" <|-- "lsm.memIterator"
"utils.Iterator" <|-- "lsm.tableIterator"

namespace pb {
    class BlockOffset << (S,Aquamarine) >> {
        + Key []byte
        + Offset uint32
        + Len uint32
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetKey() []byte
        + GetOffset() uint32
        + GetLen() uint32
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class KV << (S,Aquamarine) >> {
        + Key []byte
        + Value []byte
        + UserMeta []byte
        + Version uint64
        + ExpiresAt uint64
        + Meta []byte
        + StreamId uint32
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetKey() []byte
        + GetValue() []byte
        + GetUserMeta() []byte
        + GetVersion() uint64
        + GetExpiresAt() uint64
        + GetMeta() []byte
        + GetStreamId() uint32
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class KVList << (S,Aquamarine) >> {
        + Kv []*KV
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetKv() []*KV
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class ManifestChange << (S,Aquamarine) >> {
        + Id uint64
        + Op ManifestChange_Operation
        + Level uint32
        + Checksum []byte
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetId() uint64
        + GetOp() ManifestChange_Operation
        + GetLevel() uint32
        + GetChecksum() []byte
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class ManifestChangeSet << (S,Aquamarine) >> {
        + Changes []*ManifestChange
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetChanges() []*ManifestChange
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class ManifestChange_Operation << (S,Aquamarine) >> {
        + String() string
        + EnumDescriptor() ([]byte, []int)

    }
    class TableIndex << (S,Aquamarine) >> {
        + Offsets []*BlockOffset
        + BloomFilter []byte
        + MaxVersion uint64
        + KeyCount uint32
        + StaleDataSize uint32
        + XXX_NoUnkeyedLiteral <font color=blue>struct</font>{}
        + XXX_unrecognized []byte
        + XXX_sizecache int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + Descriptor() ([]byte, []int)
        + XXX_Unmarshal(b []byte) error
        + XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
        + XXX_Merge(src proto.Message) 
        + XXX_Size() int
        + XXX_DiscardUnknown() 
        + GetOffsets() []*BlockOffset
        + GetBloomFilter() []byte
        + GetMaxVersion() uint64
        + GetKeyCount() uint32
        + GetStaleDataSize() uint32
        + Marshal() ([]byte, error)
        + MarshalTo(dAtA []byte) (int, error)
        + MarshalToSizedBuffer(dAtA []byte) (int, error)
        + Size() int
        + Unmarshal(dAtA []byte) error

    }
    class pb.ManifestChange_Operation << (T, #FF7700) >>  {
    }
}


namespace utils {
    class Arena << (S,Aquamarine) >> {
        - n uint32
        - shouldGrow bool
        - buf []byte

        - allocate(sz uint32) uint32
        - size() int64
        - putNode(height int) uint32
        - putVal(v ValueStruct) uint32
        - putKey(key []byte) uint32
        - getNode(offset uint32) *node
        - getKey(offset uint32, size uint16) []byte
        - getVal(offset uint32, size uint32) ValueStruct
        - getNodeOffset(nd *node) uint32

    }
    class Closer << (S,Aquamarine) >> {
        - waiting sync.WaitGroup
        - ctx context.Context
        - cancel context.CancelFunc

        + CloseSignal <font color=blue>chan</font> <font color=blue>struct</font>{}

        + Close() 
        + Done() 
        + Add(n int) 
        + HasBeenClosed() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + SignalAndWait() 
        + Signal() 
        + Wait() 

    }
    class CoreMap << (S,Aquamarine) >> {
        - m sync.Map

        - keyToHash(key <font color=blue>interface</font>{}) uint64

        + Get(key <font color=blue>interface</font>{}) (<font color=blue>interface</font>{}, bool)
        + Set(key <font color=blue>interface</font>{}, value <font color=blue>interface</font>{}) 
        + Del(key <font color=blue>interface</font>{}) 
        + Range(f <font color=blue>func</font>(<font color=blue>interface</font>{}, <font color=blue>interface</font>{}) bool) 

    }
    class Entry << (S,Aquamarine) >> {
        + Key []byte
        + Value []byte
        + ExpiresAt uint64
        + Meta byte
        + Version uint64
        + Offset uint32
        + Hlen int
        + ValThreshold int64

        + Entry() *Entry
        + IsDeletedOrExpired() bool
        + WithTTL(dur time.Duration) *Entry
        + EncodedSize() uint32
        + EstimateSize(threshold int) int
        + IsZero() bool
        + LogHeaderLen() int
        + LogOffset() uint32

    }
    class Filter << (S,Aquamarine) >> {
        + MayContainKey(k []byte) bool
        + MayContain(h uint32) bool

    }
    class HashReader << (S,Aquamarine) >> {
        + R io.Reader
        + H hash.Hash32
        + BytesRead int

        + Read(p []byte) (int, error)
        + ReadByte() (byte, error)
        + Sum32() uint32

    }
    class Header << (S,Aquamarine) >> {
        + KLen uint32
        + VLen uint32
        + ExpiresAt uint64
        + Meta byte

        + Encode(out []byte) int
        + Decode(buf []byte) int
        + DecodeFrom(reader *HashReader) (int, error)

    }
    interface Item  {
        + Entry() *Entry

    }
    interface Iterator  {
        + Next() 
        + Valid() bool
        + Rewind() 
        + Item() Item
        + Close() error
        + Seek(key []byte) 

    }
    class Options << (S,Aquamarine) >> {
        + Prefix []byte
        + IsAsc bool

    }
    class SkipListIterator << (S,Aquamarine) >> {
        - list *Skiplist
        - n *node

        + Rewind() 
        + Item() Item
        + Close() error
        + Valid() bool
        + Key() []byte
        + Value() ValueStruct
        + ValueUint64() uint64
        + Next() 
        + Prev() 
        + Seek(target []byte) 
        + SeekForPrev(target []byte) 
        + SeekToFirst() 
        + SeekToLast() 

    }
    class Skiplist << (S,Aquamarine) >> {
        - height int32
        - headOffset uint32
        - ref int32
        - arena *Arena

        + OnClose <font color=blue>func</font>() 

        - randomHeight() int
        - getNext(nd *node, height int) *node
        - getHead() *node
        - findNear(key []byte, less bool, allowEqual bool) (*node, bool)
        - findSpliceForLevel(key []byte, before uint32, level int) (uint32, uint32)
        - getHeight() int32
        - findLast() *node

        + IncrRef() 
        + DecrRef() 
        + Add(e *Entry) 
        + Empty() bool
        + Search(key []byte) ValueStruct
        + NewSkipListIterator() Iterator
        + MemSize() int64
        + Draw(align bool) 

    }
    class Slice << (S,Aquamarine) >> {
        - buf []byte

    }
    class Throttle << (S,Aquamarine) >> {
        - once sync.Once
        - wg sync.WaitGroup
        - ch <font color=blue>chan</font> <font color=blue>struct</font>{}
        - errCh <font color=blue>chan</font> error
        - finishErr error

        + Do() error
        + Done(err error) 
        + Finish() error

    }
    class UniIterator << (S,Aquamarine) >> {
        - iter *Iterator
        - reversed bool

    }
    class ValuePtr << (S,Aquamarine) >> {
        + Len uint32
        + Offset uint32
        + Fid uint32

        + Less(o *ValuePtr) bool
        + IsZero() bool
        + Encode() []byte
        + Decode(b []byte) 

    }
    class ValueStruct << (S,Aquamarine) >> {
        + Meta byte
        + Value []byte
        + ExpiresAt uint64
        + Version uint64

        + EncodedSize() uint32
        + DecodeValue(buf []byte) 
        + EncodeValue(b []byte) uint32

    }
    class WalHeader << (S,Aquamarine) >> {
        + KeyLen uint32
        + ValueLen uint32
        + Meta byte
        + ExpiresAt uint64

        + Encode(out []byte) int
        + Decode(reader *HashReader) (int, error)

    }
    class WaterMark << (S,Aquamarine) >> {
        - doneUntil uint64
        - lastIndex uint64
        - markCh <font color=blue>chan</font> mark

        + Name string

        - process(closer *Closer) 

        + Init(closer *Closer) 
        + Begin(index uint64) 
        + BeginMany(indices []uint64) 
        + Done(index uint64) 
        + DoneMany(indices []uint64) 
        + DoneUntil() uint64
        + SetDoneUntil(val uint64) 
        + LastIndex() uint64
        + WaitForMark(ctx context.Context, index uint64) error

    }
    class mark << (S,Aquamarine) >> {
        - index uint64
        - waiter <font color=blue>chan</font> <font color=blue>struct</font>{}
        - indices []uint64
        - done bool

    }
    class node << (S,Aquamarine) >> {
        - value uint64
        - keyOffset uint32
        - keySize uint16
        - height uint16
        - tower []uint32

        - getValueOffset() (uint32, uint32)
        - key(arena *Arena) []byte
        - setValue(arena *Arena, vo uint64) 
        - getNextOffset(h int) uint32
        - casNextOffset(h int, old uint32, val uint32) bool
        - getVs(arena *Arena) ValueStruct

    }
    class stringStruct << (S,Aquamarine) >> {
        - str unsafe.Pointer
        - len int

    }
    class uint64Heap << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class utils.Filter << (T, #FF7700) >>  {
    }
    class utils.LogEntry << (T, #FF7700) >>  {
    }
    class utils.uint64Heap << (T, #FF7700) >>  {
    }
}

"utils.Item" <|-- "utils.Entry"
"utils.Iterator" <|-- "utils.SkipListIterator"

"__builtin__.[]byte" #.. "cache.Filter"
"__builtin__.[]byte" #.. "cache.cmRow"
"__builtin__.[]byte" #.. "utils.Filter"
"__builtin__.[]uint64" #.. "utils.uint64Heap"
"__builtin__.int32" #.. "pb.ManifestChange_Operation"
"lsm.memTable" #.. "lsm.MemTable"
"utils.<font color=blue>func</font>(*Entry, *ValuePtr) error" #.. "utils.LogEntry"
@enduml
